package finders

import (
	"github.com/pterm/pterm"
	"regexp"
	"strings"
)

func FindBrowserStealer(f []byte, re *regexp.Regexp) {
	result := re.FindAllString(string(f), -1)
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Possible browser data stealer found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, words := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        words,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}
func FindSuspiciousWords(f []byte, re *regexp.Regexp) {
	result := re.FindAllString(string(f), -1)
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Suspicious Words Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, words := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        words,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}
func FindSuspiciousRegex(f []byte) {
	var result []string
	switch {
	case strings.Contains(string(f),`mfa\.[\w-]{84}`):
		result = append(result,`mfa\.[\w-]{84}`)
	case strings.Contains(string(f),`[\w-]{24}\.[\w-]{6}\.[\w-]{27}`):
		result = append(result,`[\w-]{24}\.[\w-]{6}\.[\w-]{27}`)
	case strings.Contains(string(f),`[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}`):
		result = append(result,`[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{27}|mfa\\.[\\w-]{84}`)
	}

	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Suspicious Regex Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, regex := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        regex,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}
func FindSuspiciousCode(f []byte, re *regexp.Regexp) {

	result := re.FindAllString(string(f), -1)
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Suspicious Code Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, code := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        code,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}
func FindWebhooks(f []byte, re *regexp.Regexp) {

	result := re.FindAllString(string(f), -1)
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Webhook(s) Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, url := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        url,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}
func FindURLS(f []byte, rxStrict *regexp.Regexp) {
	result := rxStrict.FindAllString(string(f), -1)
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Urls Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, url := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        url,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}

}

func FindGrabbers(f []byte) {
	var result []string
	// Method is shitty need a find a way to make it better
	fgrabber := regexp.MustCompile(`(fgrabber.xyz|uniqueId)`)
	piratestealer := regexp.MustCompile(`(PirateMonsterInjector|GetDiscord|PirateStealer)`)
	fgrabberResult := fgrabber.FindAllString(string(f), -1)
	piratestealerResult := piratestealer.FindAllString(string(f), -1)

	switch {
	case len(fgrabberResult) != 0:
		result = append(result, "FGrabber")
	case len(piratestealerResult) != 0:
		result = append(result, "PirateStealer")
	}
	if len(result) != 0 {
		unique := MakeUnique(result)

		items := make([]pterm.BulletListItem, 0)
		firstLine := pterm.BulletListItem{
			Level:       0,
			Text:        "Possible Known Grabber Found:",
			TextStyle:   pterm.NewStyle(pterm.FgLightRed),
			Bullet:      ">",
			BulletStyle: pterm.NewStyle(pterm.FgLightGreen),
		}

		items = append(items, firstLine)

		for _, url := range unique {
			item := pterm.BulletListItem{
				Level:       1,
				Text:        url,
				Bullet:      "[+]",
				BulletStyle: pterm.NewStyle(pterm.FgCyan),
			}
			items = append(items, item)
		}

		pterm.DefaultBulletList.WithItems(items).Render()
	}
}
// Thanks stackoverflow
func MakeUnique(s []string) []string {
	unique := make(map[string]bool, len(s))
	uT := make([]string, len(unique))
	for _, elem := range s {
		if len(elem) != 0 {
			if !unique[elem] {
				uT = append(uT, elem)
				unique[elem] = true
			}
		}
	}

	return uT
}

